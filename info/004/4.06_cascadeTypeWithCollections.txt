!!! Нужно быть аккуратным с удалением при CascadeType.ALL!!!
    При удалении компании, удалятся все ее юзеры. Но если и у юзеров на компанию стоит CascadeType.ALL, то и при
    удалении юзера, удалится компания и все юзеры в ней.

    !!! Лучше использовать каскад удаление на уровне БД лоя поля с fkey
         company_id INT REFERENCES company(id) ON DELETE CASCADE
        В этом случае сама БД удалить всех пользователей при удалении нашей компании. Это будет лучше и по
        производительности (Хибер удаляет каждого пользака отдельным запросом), и с каскадным удалением в Хибере
        можно перемудрить.

На примере Company.class.
    Мы хотим, при сохранении нашей комппании, все юзеры, которые в этой компании также были сохранены. Либо удаляя
    компанию мы хотим удалять пользователей этой компании. Тогда мы выбираем CascadeType.ALL

        @OneToMany(mappedBy = "company", cascade = CascadeType.ALL)
        private Set<User> users;

    Если мы реализуем это таким образом, то мы хотим иметь метод, который добавлял бы пользователей в компанию:

         public void addUser(User user) {
                users.add(user);
                user.setCompany(this);
            }
    Зачем, если мы можем через сеттер это сделать? А все потому, что нам нужно не только юзера в компанию добавить,
    но и юзеру установить компанию. Просто на уровне нашего приложения все ссылки должны быть, как и в БД. На уровне
    приложения у нас есть ссылки как на компанию у юзера, так и у юзера на помпанию. Поэтому нам нужно указывать все эти
    связи.

    Еще момент, что мы должны инициализировать список наших юзеров на ходу, и не проверять их на налл, когда мы
    попытаемся добавить юзера. Для этого проинициализируем наш список и если это будет новый объект, то список будет
    проинициализирован; старый соответственно тоже.
    Ну и если мы используем Билдер, то для того, чтобы при создании нашей компании через билдер установилось
    деволтное значение, что и в поля @Builder.Default

         @Builder.Default
         @OneToMany(mappedBy = "company", cascade = CascadeType.ALL)
         private Set<User> users = new HashSet<>();

    Теперь добавляя юзера в компанию, мы можем использовать созданный в компании метод по добавлению юзера, и из-за
    CascadeType.ALL вместе с нашей компанией сохранится/удалиться наш юзер и создадутся все наши ассоциации и
    @OneToMany и @ManyToOne:

           //user.setCompany(company);
           //company.getUsers().add(user);

            // мы написали метод, поэтому вместо этих строк, напишем одну
            company.addUser(user);

            session.persist(company);

    - удаление
             // что бы компанию удалить, нам нужно сначала ее получить из БД. Хибер бы сделал это и сам, но лучше мы сами
             // и она будет в persistenceState и она гарантированно существует
             var company = session.get(Company.class, 3);

             session.remove(company);
             session.getTransaction().commit();
